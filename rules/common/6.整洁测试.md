# 整洁测试

![unit-testing](../../images/unit-testing.jpeg)

很多项目都没有单元测试，即使有测试，这些测试也非常难以维护！很多团队没有意识到的是，**脏测试等同于--如果不是坏于的话--没有测试！**

问题在于，测试必须要随着生产代码的演进而修改，测试越脏，就越难以修改！测试代码越缠结，你就越有可能花费更多的时间塞进新测试，而不是编写新的生产代码！修改生产代码之后，就测试就开始失败，而测试代码中乱七八糟的东西将阻碍代码再次通过。于是，测试成了研发团队难缠的债务！

随着版本的递进，团队维护测试代码组的代价也在上升，最终，它们变成了研发组最大的抱怨对象。当经理们问到为何超支如此巨大，开发者就将其归咎于测试！最后，它们只能扔掉整个测试代码组。

但是，没有了测试代码组，他们就失去了确保对代码的改动能如愿工作的能力，没有了测试代码组，它们就没法确保对系统某个部分的修改不会影响到系统的其他部分。故障开始增加。随着并非出自有意的故障越来越多，它们开始害怕被改动。他们不再开始清理生产代码，因为他们害怕修改带来的损害多于收益。生产代码开始腐坏，最后他们只剩下没有测试、纷乱而缺陷缠身的的生产代码，沮丧的客户，还有对测试的失望！

在某种意义上他们说对了，测试的确让他们失望，不过是他们自己决定让测试变得乱七八糟的，而那正是失败的根源！相反，如果有了测试，愁云会一扫而空，测试覆盖率越高，你就越不担心修改带来的变动。哪怕是那些对于架构并不优秀，设计晦涩纠缠的代码，你也能近乎没有后患的做出修改，实际上，你可以毫无顾忌的改进架构和设计！所以，我们得出了如下的结论：

***测试代码和生产代码同等重要！！！***

测试也需要像生产代码一样被照顾，被思考，被设计和维护，它们应该像生产代码一样保持整洁！

## 整洁的测试

整洁的测试有什么诀窍？有三个：

***可读性，可读性，还是他妈的可读性！！！***

在单元测试中，可读性甚至比生产代码还重要！测试如何才能做到可读？和生产代码一样：明确，简洁，还有足够的表达力！

#### 单一职责

单一职责原则在软件中的任何地方都通用！有个流派甚至认为，Junit中的每个测试函数应该有且仅有一个断言语句。这条规则看似过于苛刻，但好处是可以让你快速的理解该测试表达的意图！

当然，我并不完全推荐每个测试只有一个断言，但是我想强调的是，每个单元测试应该只测***一个最小的不可被分割的业务逻辑！***

换句话说，每个测试应该只测试一个概念！我们不推荐那种超长的测试，测试完这个，又要测试那个！

## FIRST原则

整洁的测试还需要遵守如下5条规则，这5条规则的首字母构成了单词FIRST！

* **快速(Fast)**: 测试应该够快。测试应该能够被快速运行，如果测试运行缓慢，你就不会想要频繁的运行他们！他如果你不频繁的运行测试，就不能尽早发现问题，也无法修正问题，从而也不能轻而易举的清理代码，最终代码就开始变得腐坏。
* **独立(Independent)**: 测试应该互相独立。某个测试不应为下一个测试设定条件，你应该可以单独运行每个测试以及任何顺序运行测试，当测试互相依赖时，头一个没通过就会导致一连串的测试失败，使问题诊断变得困难，隐藏了下级错误。
* **可重复(Repeatable)**: 测试应当可在任何环境中重复通过，你应该能够在生产环境、质检环境中运行测试，也能够在无线网络的列车上用笔记本电脑运行测试，如果测试不能在任何一环境中重复，你就总会有个解释其失败的借口，当环境不具备时，你也会无法运行测试。
* **自验证(Self-Validating)**: 测试应该有布尔值输出。无论是通过或失败，你不应该查看日志文件来确认测试是否通过，你不应该手工对比两个不同文本文件来确认测试是否通过，如果测试不能自足验证，对失败的判断就会变得依赖主观，而运行测试也需要更长的手工操作时间。
* **及时(Timely)**: 测试应该及时编写。单元测试应该恰好在使其通过的生产代码之前编写，如果在编写生产代码之后编写测试，你会发现生产代码难以测试，你可能会认为某些生产代码本身难以测试，你可能不会去设计可测试的代码！