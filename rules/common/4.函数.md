# 函数

![clean code](../../images/function.png)

函数是程序的基本逻辑处理单元，在我的职业生涯中，有幸维护过一个大约有5000行代码的函数，这个函数几乎包罗万象，应有应有，里面的逻辑更是错综复杂，相信只有真正经历过的人，才知道这是一件多么艰巨而痛苦的事情！

所以，写好一个函数，就两个规则：

***第一个规则是要短小，第二个规则是更加短小！***

我无法证明这个断言，也给不出任何证实了小函数更好的研究结果，但是经过漫长的试错，经验告诉我，函数就应该短小！

那么，函数到底该有多长？我们常说的函数不能超过一屏。当然，现在很多的大屏显示器，一屏可以显示100多行，***我觉得这太长了，20行应该是封顶了，15行以内应该最佳！***

那如何做到这么短小呢？请记住下面的原则：

***函数应该做一件事！做好这一件事情！只做这一件事情！***

我们先来看个例子，这个例子是我刚刚开始接触Java编程时练习过的代码：
```java
public void greetings(String timePhase) {
    if (timePhase.equals("morning")) {
        System.out.println("Good morning");
    } else if (timePhase.equals("afternoon")) {
        System.out.println("Good afternoon");
    } else if (timePhase.equals("evening")) {
        System.out.println("Good evening");
    } else {
        System.out.println("Good night");
    }
}
```

你觉得上面的代码如何？当我第一次运行它成功的时候，感觉自己棒极了！

但是慢慢的发现，里面有太多的`if...else`判断语句了，当我新增一种条件的时候，就必须添加一个新的判断语句！

当我后面学习到`switch`语句的时候，觉得这个简直太棒了，我可以将其改写如下：
```java
public void greetings(String timePhase) {
    TimePhase timePhaseEnum = TimePhase.valueOf(timePhase.toUpperCase());
    switch (timePhaseEnum) {
        case MORNING:
            System.out.println("Good morning");
            break;
        case AFTERNOON:
            System.out.println("Good afternoon");
            break;
        case EVENING:
            System.out.println("Good evening");
            break;
        case NIGHT:
        default:
            System.out.println("Good night");
    }
}
enum TimePhase {
    MORNING, AFTERNOON, EVENING, NIGHT;
}
```

上面的写法虽然比`if...else`好些，但是仍然没有解决根本问题：当我新增一种条件的时候，就必须添加一个新的判断语句！

为什么会这样呢？因为上面的代码做了两件事情：
1. 判断`timePhase`代表的时间段。
2. 打印相关的欢迎语。

那么我们将这两件事情分离开来如何？
```java
public class Demo {
    public static void greetings(String timePhase) {
        getGreetings(timePhase).ifPresent(Demo::printGreeting);
    }

    private static Optional<String> getGreetings(String timePhase) {
        return Arrays.stream(TimePhase.values())
                .map(val -> val.name().toLowerCase())
                .filter(val -> val.equals(timePhase))
                .findFirst();
    }

    private static void printGreeting(String timePhase) {
        System.out.println("Good " + timePhase);
    }
}

enum TimePhase {
    MORNING, AFTERNOON, EVENING, NIGHT;
}
```

你看看，可读性好多了吧！当你增加一个新的`TimePhase`的时候，几乎不需要更改任何其他逻辑吧？！

## 单一职责原则（Single Responsibility Principle）

单一职责原则(SRP)认为：一个类或模块有且仅有一个被修改的理由！这一原则同样使用与方法！

SRP是OO设计中最为重要的概念之一，也是较为容易理解和遵守的概念之一。奇怪的是，SRP往往也是最容易被破坏的设计原则。为什么呢？

让软件能工作和让软件保持整洁，是两种截然不同的工作。我们中的大多数人脑力有限，只能更多的把精力放在软件可以工作上，而不是放在保持代码有组织和整洁上。与此同时，许多开发者害怕数量巨大的短小单一目的的类或者方法会导致难以一目了然的抓住全局，他们认为，要搞清楚一件较大工作如何完成，就得在类与类之间找来找去。

然而，有大量短小类或者函数的系统，并不比有少量庞大类的系统拥有更多移动部件，其数量大致相等。关键问题是：你是想把工具归置到有许多抽屉、每个抽屉中装有定义和标记良好的组件的工具箱呢？还是想要少数几个能随便把所有东西扔进去的抽屉？

每个达到一定规模的系统会包含大量逻辑和复杂性。管理这种复杂性的首要目标就是加以组织，以便开发者知道哪儿能找到东西，并且在某个特定时间只需要理解直接有关的复杂性。

最后强调一下：

***系统应该有许多短小的类和方法组成，每个类或方法都被封装成一个职责单一的组件，并且与少数其他类一起协同达成期望的系统行为！***

反观上面的案例，上面的函数职责并不单一(做了两件事情)，所以就会存在多个被修改的理由！经过重构，每个短小的方法就只有一个被修改的理由。





